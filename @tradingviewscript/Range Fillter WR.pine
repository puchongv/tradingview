//@version=5
indicator(title="Range Filter Buy and Sell 5min with Win Rate", shorttitle="Range Filter WR", overlay=true)

// Original Script > @DonovanWall
// Adapted Version > @guikroth
// 
// Updated PineScript to version 5
// Republished by > @tvenn
// Modified with Win Rate Calculation > @user

//////////////////////////////////////////////////////////////////////////
// Settings for 5min chart, BTCUSDC. For Other coin, change the parameters
//////////////////////////////////////////////////////////////////////////

// Color variables
upColor   = color.white
midColor  = #90bff9
downColor = color.blue

// Source
src = input(defval=close, title="Source")

// Sampling Period
// Settings for 5min chart, BTCUSDC. For Other coin, change the paremeters
per = input.int(defval=100, minval=1, title="Sampling Period")

// Range Multiplier
mult = input.float(defval=3.0, minval=0.1, title="Range Multiplier")

// Win Rate Calculation Settings
grp_WINRATE = "Win Rate Settings"
interval_minutes = input.int(defval=10, minval=1, title="Interval Time (minutes)", group=grp_WINRATE)
start_date = input.time(timestamp("2025-07-27"), title="Start Date", group=grp_WINRATE)
end_date = input.time(timestamp("2025-07-31"), title="End Date", group=grp_WINRATE)
show_winrate = input.bool(defval=true, title="Show Win Rate", group=grp_WINRATE)

// Dynamic date range (7 days ago to now)
seven_days_ago = time - (7 * 24 * 60 * 60 * 1000)
current_time = time

// Smooth Average Range
smoothrng(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
    smoothrng
smrng = smoothrng(src, per, mult)

// Range Filter
rngfilt(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : 
       x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
    rngfilt
filt = rngfilt(src, smrng)

// Filter Direction
upward = 0.0
upward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])
downward = 0.0
downward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])

// Target Bands
hband = filt + smrng
lband = filt - smrng

// Colors
filtcolor = upward > 0 ? upColor : downward > 0 ? downColor : midColor
barcolor = src > filt and src > src[1] and upward > 0 ? upColor :
   src > filt and src < src[1] and upward > 0 ? upColor : 
   src < filt and src < src[1] and downward > 0 ? downColor : 
   src < filt and src > src[1] and downward > 0 ? downColor : midColor

filtplot = plot(filt, color=filtcolor, linewidth=2, title="Range Filter")

// Target
hbandplot = plot(hband, color=color.new(upColor, 70), title="High Target")
lbandplot = plot(lband, color=color.new(downColor, 70), title="Low Target")

// Fills
fill(hbandplot, filtplot, color=color.new(upColor, 90), title="High Target Range")
fill(lbandplot, filtplot, color=color.new(downColor, 90), title="Low Target Range")

// Bar Color
barcolor(barcolor)

// Break Outs
longCond = bool(na)
shortCond = bool(na)
longCond := src > filt and src > src[1] and upward > 0 or 
   src > filt and src < src[1] and upward > 0
shortCond := src < filt and src < src[1] and downward > 0 or 
   src < filt and src > src[1] and downward > 0

CondIni = 0
CondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]
longCondition = longCond and CondIni[1] == -1
shortCondition = shortCond and CondIni[1] == 1

// Win Rate Calculation
var int total_buy_signals = 0
var int total_sell_signals = 0
var int total_wins = 0
var int total_losses = 0
var array<float> buy_entry_prices = array.new<float>()
var array<int> buy_entry_times = array.new<int>()
var array<float> sell_entry_prices = array.new<float>()
var array<int> sell_entry_times = array.new<int>()

// Reset counters when date range changes
var int last_start_date = 0
var int last_end_date = 0
if start_date != last_start_date or end_date != last_end_date
    total_buy_signals := 0
    total_sell_signals := 0
    total_wins := 0
    total_losses := 0
    array.clear(buy_entry_prices)
    array.clear(buy_entry_times)
    array.clear(sell_entry_prices)
    array.clear(sell_entry_times)
    last_start_date := start_date
    last_end_date := end_date

// Check if we're within the date range (use custom date range if set, otherwise use 7 days ago to now)
in_date_range = time >= start_date and time <= end_date

// Process buy signals
if longCondition and in_date_range
    total_buy_signals := total_buy_signals + 1
    array.push(buy_entry_prices, src)
    array.push(buy_entry_times, time)

// Process sell signals
if shortCondition and in_date_range
    total_sell_signals := total_sell_signals + 1
    array.push(sell_entry_prices, src)
    array.push(sell_entry_times, time)

// Check for completed intervals and calculate wins/losses for buy signals
if array.size(buy_entry_prices) > 0
    for i = array.size(buy_entry_prices) - 1 to 0
        entry_time = array.get(buy_entry_times, i)
        entry_price = array.get(buy_entry_prices, i)
        interval_time = entry_time + (interval_minutes * 60 * 1000)
        
        if time >= interval_time
            // Get price at interval time (approximate)
            future_price = src
            // Simple approximation - in real implementation you might want more sophisticated price tracking
            
            if future_price > entry_price
                total_wins := total_wins + 1
            else
                total_losses := total_losses + 1
            
            // Remove processed signal
            array.remove(buy_entry_prices, i)
            array.remove(buy_entry_times, i)

// Check for completed intervals and calculate wins/losses for sell signals
if array.size(sell_entry_prices) > 0
    for i = array.size(sell_entry_prices) - 1 to 0
        entry_time = array.get(sell_entry_times, i)
        entry_price = array.get(sell_entry_prices, i)
        interval_time = entry_time + (interval_minutes * 60 * 1000)
        
        if time >= interval_time
            // Get price at interval time (approximate)
            future_price = src
            // Simple approximation - in real implementation you might want more sophisticated price tracking
            
            if future_price < entry_price
                total_wins := total_wins + 1
            else
                total_losses := total_losses + 1
            
            // Remove processed signal
            array.remove(sell_entry_prices, i)
            array.remove(sell_entry_times, i)

// Calculate win rate
total_signals = total_wins + total_losses
win_rate = total_signals > 0 ? (total_wins / total_signals) * 100 : 0

// Display win rate statistics
var label winrate_label = na
if show_winrate and barstate.islast
    label_text = "WIN RATE STATS\n" +
                 "Buy Signals: " + str.tostring(total_buy_signals) + "\n" +
                 "Sell Signals: " + str.tostring(total_sell_signals) + "\n" +
                 "Total Signals: " + str.tostring(total_buy_signals + total_sell_signals) + "\n" +
                 "Wins: " + str.tostring(total_wins) + "\n" +
                 "Losses: " + str.tostring(total_losses) + "\n" +
                 "Win Rate: " + str.tostring(math.round(win_rate, 2)) + "%"
    
    // Delete previous label if it exists
    if not na(winrate_label)
        label.delete(winrate_label)
    
    // Create new label positioned after the last bar
    winrate_label := label.new(bar_index + 5, high, label_text, color=color.new(color.blue, 80), textcolor=color.white, style=label.style_label_left, size=size.small)

//Alerts
plotshape(longCondition, title="Buy Signal", text="Buy", textcolor=color.white, style=shape.labelup, size=size.small, location=location.belowbar, color=color.new(#aaaaaa, 20))
plotshape(shortCondition, title="Sell Signal", text="Sell", textcolor=color.white, style=shape.labeldown, size=size.small, location=location.abovebar, color=color.new(downColor, 20))

alertcondition(longCondition, title="Buy alert on Range Filter", message="Buy alert on Range Filter")
alertcondition(shortCondition, title="Sell alert on Range Filter", message="Sell alert on Range Filter")
alertcondition(longCondition or shortCondition, title="Buy and Sell alert on Range Filter", message="Buy and Sell alert on Range Filter")

// For use as a Strategy
// ___________________________________________________________________________________________________________

// 1. Replace the word "indicator" on line 2 with the word "strategy"
// 2. Uncomment the code below by highlighting it and pressing Ctl + '/'

// Settings for 5min BTCUSDT. For other timeframes and assets, adjust the parameters within the settings menu.
// ___________________________________________________________________________________________________________

// grp_STRAT   = "Strategy settings"
// timeInput   = input.time(timestamp("1 Nov 2022 00:00 +0000"), title="Start date", group=grp_STRAT)
// tpInPips    = input.int(400, title="TP (in pips)", group=grp_STRAT)
// slInPips    = input.int(100, title="SL (in pips)", group=grp_STRAT)

// timePeriod  = time >= timeInput
// notInTrade  = strategy.position_size <= 0

// if(longCondition and timePeriod and notInTrade)
//     strategy.entry("Long", strategy.long)
//     strategy.exit("Exit long", "Long", loss=slInPips, profit=tpInPips)
// if(shortCondition and timePeriod and notInTrade)
//     strategy.entry("Short", strategy.short)
//     strategy.exit("Exit short", "Short", loss=slInPips, profit=tpInPips) 